{
  "version": 3,
  "sources": ["../src/lzma.js"],
  "sourcesContent": ["//! \u00A9 2015 Nathan Rugg <nmrugg@gmail.com> | MIT\r\n/// See LICENSE for more details.\r\n\r\n// jshint bitwise:true, curly:true, eqeqeq:true, forin:true, immed:true, latedef:true, newcap:true, noarg:true, noempty:true, nonew:true, onevar:true, plusplus:true, quotmark:double, undef:true, unused:strict, browser: true, node: true\r\n\r\n/// Does the environment support web workers?  If not, let's load the worker manually (without polluting the global scope).\r\nif (\r\n  typeof Worker === \"undefined\" ||\r\n  (typeof location !== \"undefined\" && location.protocol === \"file:\")\r\n) {\r\n  /// Is this Node.js?\r\n  if (typeof global !== \"undefined\" && typeof require !== \"undefined\") {\r\n    this.LZMA = function (lzma_path) {\r\n      return require(lzma_path || \"./lzma_worker.js\").LZMA;\r\n    };\r\n    /// Is this a browser?\r\n  } else if (typeof window !== \"undefined\" && window.document) {\r\n    (function () {\r\n      var that = this,\r\n        global_var,\r\n        req = function req(path) {\r\n          var script_tag = document.createElement(\"script\");\r\n          script_tag.type = \"text/javascript\";\r\n          script_tag.src = path;\r\n          script_tag.onload = function () {\r\n            /// Make sure this LZMA variable doesn't get overwritten by the worker's.\r\n            that.LZMA = non_worker_lzma;\r\n          };\r\n          document.getElementsByTagName(\"head\")[0].appendChild(script_tag);\r\n        };\r\n\r\n      /// Determine the global variable (it's called \"window\" in browsers, \"global\" in Node.js).\r\n      if (typeof window !== \"undefined\") {\r\n        global_var = window;\r\n      } else if (global) {\r\n        global_var = global;\r\n      }\r\n\r\n      function non_worker_lzma(path) {\r\n        var fake_lzma;\r\n\r\n        req(path);\r\n\r\n        fake_lzma = {\r\n          compress: function compress(mixed, mode, on_finish, on_progress) {\r\n            if (global_var.LZMA_WORKER) {\r\n              global_var.LZMA_WORKER.compress(\r\n                mixed,\r\n                mode,\r\n                on_finish,\r\n                on_progress\r\n              );\r\n            } else {\r\n              /// Wait\r\n              setTimeout(function () {\r\n                fake_lzma.compress(mixed, mode, on_finish, on_progress);\r\n              }, 50);\r\n            }\r\n          },\r\n          decompress: function decompress(byte_arr, on_finish, on_progress) {\r\n            if (global_var.LZMA_WORKER) {\r\n              global_var.LZMA_WORKER.decompress(\r\n                byte_arr,\r\n                on_finish,\r\n                on_progress\r\n              );\r\n            } else {\r\n              /// Wait\r\n              setTimeout(function () {\r\n                fake_lzma.decompress(byte_arr, on_finish, on_progress);\r\n              }, 50);\r\n            }\r\n          },\r\n          worker: function worker() {\r\n            return null;\r\n          },\r\n        };\r\n\r\n        return fake_lzma;\r\n      }\r\n\r\n      that.LZMA = non_worker_lzma;\r\n    })();\r\n  } else {\r\n    /// It doesn't seem to be either Node.js or a browser.\r\n    console.error(\"Can't load the worker. Sorry.\");\r\n  }\r\n} else {\r\n  /// Let's use Web Workers.\r\n  ///NOTE: The \"this\" keyword is the global context (\"window\" variable) if loaded via a <script> tag\r\n  ///      or the function context if loaded as a module (e.g., in Node.js).\r\n  this.LZMA = function (lzma_path) {\r\n    var action_compress = 1,\r\n      action_decompress = 2,\r\n      action_progress = 3,\r\n      callback_obj = {},\r\n      ///NOTE: Node.js needs something like \"./\" or \"../\" at the beginning.\r\n      lzma_worker = new Worker(lzma_path || \"./lzma_worker.js\");\r\n\r\n    lzma_worker.onmessage = function onmessage(e) {\r\n      if (e.data.action === action_progress) {\r\n        if (\r\n          callback_obj[e.data.cbn] &&\r\n          typeof callback_obj[e.data.cbn].on_progress === \"function\"\r\n        ) {\r\n          callback_obj[e.data.cbn].on_progress(e.data.result);\r\n        }\r\n      } else {\r\n        if (\r\n          callback_obj[e.data.cbn] &&\r\n          typeof callback_obj[e.data.cbn].on_finish === \"function\"\r\n        ) {\r\n          callback_obj[e.data.cbn].on_finish(e.data.result, e.data.error);\r\n\r\n          /// Since the (de)compression is complete, the callbacks are no longer needed.\r\n          delete callback_obj[e.data.cbn];\r\n        }\r\n      }\r\n    };\r\n\r\n    /// Very simple error handling.\r\n    lzma_worker.onerror = function (event) {\r\n      var err = new Error(\r\n        event.message + \" (\" + event.filename + \":\" + event.lineno + \")\"\r\n      );\r\n\r\n      for (var cbn in callback_obj) {\r\n        callback_obj[cbn].on_finish(null, err);\r\n      }\r\n\r\n      console.error(\"Uncaught error in lzma_worker\", err);\r\n    };\r\n\r\n    return (function () {\r\n      function send_to_worker(action, data, mode, on_finish, on_progress) {\r\n        var cbn;\r\n\r\n        do {\r\n          cbn = Math.floor(Math.random() * 10000000);\r\n        } while (typeof callback_obj[cbn] !== \"undefined\");\r\n\r\n        callback_obj[cbn] = {\r\n          on_finish: on_finish,\r\n          on_progress: on_progress,\r\n        };\r\n\r\n        lzma_worker.postMessage({\r\n          action: action, /// action_compress = 1, action_decompress = 2, action_progress = 3\r\n          cbn: cbn, /// callback number\r\n          data: data,\r\n          mode: mode,\r\n        });\r\n      }\r\n\r\n      return {\r\n        compress: function compress(mixed, mode, on_finish, on_progress) {\r\n          send_to_worker(action_compress, mixed, mode, on_finish, on_progress);\r\n        },\r\n        decompress: function decompress(byte_arr, on_finish, on_progress) {\r\n          send_to_worker(\r\n            action_decompress,\r\n            byte_arr,\r\n            false,\r\n            on_finish,\r\n            on_progress\r\n          );\r\n        },\r\n        worker: function worker() {\r\n          return lzma_worker;\r\n        },\r\n      };\r\n    })();\r\n  };\r\n}\r\n"],
  "mappings": "AAAA,AAMA,AACE,MAAO,SAAW,aACjB,MAAO,WAAa,aAAe,SAAS,WAAa,QAG1D,AAAI,MAAO,SAAW,aAAe,MAAO,UAAY,YACtD,QAAK,KAAO,SAAU,EAAW,CAC/B,MAAO,SAAQ,GAAa,oBAAoB,MAG7C,AAAI,MAAO,SAAW,aAAe,OAAO,SAChD,UAAY,CACX,GAAI,GAAO,KACT,EACA,EAAM,SAAa,EAAM,CACvB,GAAI,GAAa,SAAS,cAAc,UACxC,EAAW,KAAO,kBAClB,EAAW,IAAM,EACjB,EAAW,OAAS,UAAY,CAE9B,EAAK,KAAO,GAEd,SAAS,qBAAqB,QAAQ,GAAG,YAAY,IAIzD,AAAI,MAAO,SAAW,YACpB,EAAa,OACJ,QACT,GAAa,QAGf,WAAyB,EAAM,CAC7B,GAAI,GAEJ,SAAI,GAEJ,EAAY,CACV,SAAU,SAAkB,EAAO,EAAM,EAAW,EAAa,CAC/D,AAAI,EAAW,YACb,EAAW,YAAY,SACrB,EACA,EACA,EACA,GAIF,WAAW,UAAY,CACrB,EAAU,SAAS,EAAO,EAAM,EAAW,IAC1C,KAGP,WAAY,SAAoB,EAAU,EAAW,EAAa,CAChE,AAAI,EAAW,YACb,EAAW,YAAY,WACrB,EACA,EACA,GAIF,WAAW,UAAY,CACrB,EAAU,WAAW,EAAU,EAAW,IACzC,KAGP,OAAQ,UAAkB,CACxB,MAAO,QAIJ,EAGT,EAAK,KAAO,KAId,QAAQ,MAAM,iCAMhB,QAAK,KAAO,SAAU,EAAW,CAC/B,GAAI,GAAkB,EACpB,EAAoB,EACpB,EAAkB,EAClB,EAAe,GAEf,EAAc,GAAI,QAAO,GAAa,oBAExC,SAAY,UAAY,SAAmB,EAAG,CAC5C,AAAI,EAAE,KAAK,SAAW,EAElB,EAAa,EAAE,KAAK,MACpB,MAAO,GAAa,EAAE,KAAK,KAAK,aAAgB,YAEhD,EAAa,EAAE,KAAK,KAAK,YAAY,EAAE,KAAK,QAI5C,EAAa,EAAE,KAAK,MACpB,MAAO,GAAa,EAAE,KAAK,KAAK,WAAc,YAE9C,GAAa,EAAE,KAAK,KAAK,UAAU,EAAE,KAAK,OAAQ,EAAE,KAAK,OAGzD,MAAO,GAAa,EAAE,KAAK,OAMjC,EAAY,QAAU,SAAU,EAAO,CACrC,GAAI,GAAM,GAAI,OACZ,EAAM,QAAU,KAAO,EAAM,SAAW,IAAM,EAAM,OAAS,KAG/D,OAAS,KAAO,GACd,EAAa,GAAK,UAAU,KAAM,GAGpC,QAAQ,MAAM,gCAAiC,IAGzC,UAAY,CAClB,WAAwB,EAAQ,EAAM,EAAM,EAAW,EAAa,CAClE,GAAI,GAEJ,EACE,GAAM,KAAK,MAAM,KAAK,SAAW,WAC1B,MAAO,GAAa,IAAS,aAEtC,EAAa,GAAO,CAClB,UAAW,EACX,YAAa,GAGf,EAAY,YAAY,CACtB,OAAQ,EACR,IAAK,EACL,KAAM,EACN,KAAM,IAIV,MAAO,CACL,SAAU,SAAkB,EAAO,EAAM,EAAW,EAAa,CAC/D,EAAe,EAAiB,EAAO,EAAM,EAAW,IAE1D,WAAY,SAAoB,EAAU,EAAW,EAAa,CAChE,EACE,EACA,EACA,GACA,EACA,IAGJ,OAAQ,UAAkB,CACxB,MAAO",
  "names": []
}
